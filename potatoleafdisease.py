# -*- coding: utf-8 -*-
"""PotatoLeafDisease.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S1VoLGtGsyj8A4qR0UKS9p2KjGzAX78P

# POTATO LEAF DISEASE

# Installation
"""

!pip install tensorflow
!pip install keras
!pip install Keras-Preprocessing
!pip install opencv-python
!pip install scikeras

"""#Importing Libraries"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
from PIL import Image
import os

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.preprocessing import image_dataset_from_directory
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.optimizers import Adam, Adamax
from tensorflow.keras.metrics import categorical_crossentropy
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Activation, Dropout, BatchNormalization
from tensorflow.keras import regularizers
from tensorflow.keras.models import Model
from tensorflow import keras
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import json

"""#Mount Google Drive"""

from google.colab import drive
drive.mount('/content/drive')

"""#Read the data"""

# Update the path to point to your dataset in Google Drive
path = '/content/drive/MyDrive/Hoverin-data/color'

# Load the dataset
train_ds , test_ds = keras.utils.image_dataset_from_directory(
    path,
    image_size=(224, 224),
    batch_size=32,
    seed=123,
    validation_split=.2,
    subset='both'
)

# E:\Hoverin\DataSet\Potato\color\Potato___Early_blight

"""# Classes in the training dataset"""

classes = train_ds.class_names
classes

"""# Visualize some images"""

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Potato___healthy'

# List all files in the directory
files = os.listdir(directory_path)

# Select the first image in the directory (you can modify this as needed)
image_path = os.path.join(directory_path, files[0])

# Load the image using PIL
image = Image.open(image_path)

# Convert PIL image to NumPy array
image_np = np.array(image)

# Display the image
plt.figure(figsize=(5, 5))
plt.imshow(image_np)
plt.title('Healthy', size=10)
plt.axis('off')
plt.show()

"""## Healthy leaf"""

from PIL import Image
import os

# Specify the path to the directory containing healthy images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Potato___healthy'

# List all files in the directory
files = os.listdir(directory_path)

# Set up a subplot for each image
num_images = len(files)
rows = int(np.ceil(np.sqrt(num_images)))
cols = int(np.ceil(num_images / rows))

# Create a figure and axis
fig, axs = plt.subplots(rows, cols, figsize=(15, 15))

# Iterate through files and display each image
for i, file in enumerate(files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles
plt.tight_layout()
plt.show()

"""##Early blight"""

import matplotlib.pyplot as plt
from PIL import Image
import os

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Potato___Early_blight'

# List only image files in the directory (assuming they have extensions like .jpg, .png, etc.)
image_files = [file for file in os.listdir(directory_path) if file.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Take only the first 100 image files
image_files = image_files[:100]

# Calculate the number of rows and columns needed for the 100 images
rows = 10  # Assuming 10 rows for a visually appealing grid
cols = 10

# Create a figure and axis with the specified number of subplots
fig, axs = plt.subplots(rows, cols, figsize=(20, 15), constrained_layout=True)

# Iterate through the first 100 image files and display each image
for i, file in enumerate(image_files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles and ensure a well-organized grid
plt.tight_layout()
plt.show()

"""##Late blight"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import os

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Potato___Late_blight'

# List only image files in the directory (assuming they have extensions like .jpg, .png, etc.)
image_files = [file for file in os.listdir(directory_path) if file.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Take only the first 100 image files
image_files = image_files[:100]

# Calculate the number of rows and columns needed for the 100 images
rows = 10  # Assuming 10 rows for a visually appealing grid
cols = 10

# Create a figure and axis with the specified number of subplots
fig, axs = plt.subplots(rows, cols, figsize=(20, 15), constrained_layout=True)

# Iterate through the first 100 image files and display each image
for i, file in enumerate(image_files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles and ensure a well-organized grid
plt.tight_layout()
plt.show()

"""##Bacteria"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import os

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Bacteria'

# List only image files in the directory (assuming they have extensions like .jpg, .png, etc.)
image_files = [file for file in os.listdir(directory_path) if file.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Take only the first 100 image files
image_files = image_files[:100]

# Calculate the number of rows and columns needed for the 100 images
rows = 10  # Assuming 10 rows for a visually appealing grid
cols = 10

# Create a figure and axis with the specified number of subplots
fig, axs = plt.subplots(rows, cols, figsize=(20, 15), constrained_layout=True)

# Iterate through the first 100 image files and display each image
for i, file in enumerate(image_files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles and ensure a well-organized grid
plt.tight_layout()
plt.show()

"""##Fungi"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import os

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Fungi'

# List only image files in the directory (assuming they have extensions like .jpg, .png, etc.)
image_files = [file for file in os.listdir(directory_path) if file.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Take only the first 100 image files
image_files = image_files[:100]

# Calculate the number of rows and columns needed for the 100 images
rows = 10  # Assuming 10 rows for a visually appealing grid
cols = 10

# Create a figure and axis with the specified number of subplots
fig, axs = plt.subplots(rows, cols, figsize=(20, 15), constrained_layout=True)

# Iterate through the first 100 image files and display each image
for i, file in enumerate(image_files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles and ensure a well-organized grid
plt.tight_layout()
plt.show()

"""##Nematode"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import os

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Nematode'

# List only image files in the directory (assuming they have extensions like .jpg, .png, etc.)
image_files = [file for file in os.listdir(directory_path) if file.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Take only the first 100 image files
image_files = image_files[:100]

# Calculate the number of rows and columns needed for the 100 images
rows = 10  # Assuming 10 rows for a visually appealing grid
cols = 10

# Create a figure and axis with the specified number of subplots
fig, axs = plt.subplots(rows, cols, figsize=(20, 15), constrained_layout=True)

# Iterate through the first 100 image files and display each image
for i, file in enumerate(image_files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles and ensure a well-organized grid
plt.tight_layout()
plt.show()

"""##Pest"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import os

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Pest'

# List only image files in the directory (assuming they have extensions like .jpg, .png, etc.)
image_files = [file for file in os.listdir(directory_path) if file.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Take only the first 100 image files
image_files = image_files[:100]

# Calculate the number of rows and columns needed for the 100 images
rows = 10  # Assuming 10 rows for a visually appealing grid
cols = 10

# Create a figure and axis with the specified number of subplots+
fig, axs = plt.subplots(rows, cols, figsize=(20, 15), constrained_layout=True)

# Iterate through the first 100 image files and display each image
for i, file in enumerate(image_files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles and ensure a well-organized grid
plt.tight_layout()
plt.show()

"""##Phytopthora"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import os

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Phytopthora'

# List only image files in the directory (assuming they have extensions like .jpg, .png, etc.)
image_files = [file for file in os.listdir(directory_path) if file.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Take only the first 100 image files
image_files = image_files[:100]

# Calculate the number of rows and columns needed for the 100 images
rows = 10  # Assuming 10 rows for a visually appealing grid
cols = 10

# Create a figure and axis with the specified number of subplots
fig, axs = plt.subplots(rows, cols, figsize=(20, 15), constrained_layout=True)

# Iterate through the first 100 image files and display each image
for i, file in enumerate(image_files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles and ensure a well-organized grid
plt.tight_layout()
plt.show()

"""##Virus"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import os

# Specify the path to the directory containing images
directory_path = '/content/drive/MyDrive/PotatoDataset/color/Virus'

# List only image files in the directory (assuming they have extensions like .jpg, .png, etc.)
image_files = [file for file in os.listdir(directory_path) if file.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Take only the first 100 image files
image_files = image_files[:100]

# Calculate the number of rows and columns needed for the 100 images
rows = 10  # Assuming 10 rows for a visually appealing grid
cols = 10

# Create a figure and axis with the specified number of subplots
fig, axs = plt.subplots(rows, cols, figsize=(20, 15), constrained_layout=True)

# Iterate through the first 100 image files and display each image
for i, file in enumerate(image_files):
    # Construct the full path to the image
    image_path = os.path.join(directory_path, file)

    # Load the image using PIL
    image = Image.open(image_path)

    # Convert PIL image to NumPy array
    image_np = np.array(image)

    # Display the image on the subplot
    row = i // cols
    col = i % cols
    axs[row, col].imshow(image_np)
    axs[row, col].set_title(f'Image {i+1}')
    axs[row, col].axis('off')

# Adjust layout to prevent clipping of titles and ensure a well-organized grid
plt.tight_layout()
plt.show()

"""# Build Neural Network (CNN)"""

from tensorflow import keras

model = keras.Sequential([
    keras.layers.Rescaling(scale=1/255, input_shape=(224, 224, 3)),

    keras.layers.Conv2D(32, (3, 3), activation=keras.layers.LeakyReLU(alpha=0.2)),
    keras.layers.MaxPool2D((2, 2)),
    keras.layers.Dropout(0.2),

    keras.layers.Conv2D(64, (3, 3), activation=keras.layers.LeakyReLU(alpha=0.2)),
    keras.layers.MaxPool2D((2, 2)),
    keras.layers.Dropout(0.2),

    keras.layers.Conv2D(64, (3, 3), activation=keras.layers.LeakyReLU(alpha=0.2)),
    keras.layers.MaxPool2D((2, 2)),
    keras.layers.Dropout(0.2),

    keras.layers.Conv2D(64, (3, 3), activation=keras.layers.LeakyReLU(alpha=0.2)),
    keras.layers.MaxPool2D((2, 2)),
    keras.layers.Dropout(0.2),

    keras.layers.Conv2D(128, (3, 3), activation=keras.layers.LeakyReLU(alpha=0.2)),
    keras.layers.MaxPool2D((2, 2)),

    # fully connected layers

    keras.layers.Flatten(),
    keras.layers.Dense(128, activation=keras.layers.LeakyReLU(alpha=0.2)),
    keras.layers.Dense(64, activation=keras.layers.LeakyReLU(alpha=0.2)),
    keras.layers.Dense(38, activation='sigmoid')
])

"""##Compile the model"""

#Compile the model with an optimizer, loss function, and metrics

model.compile(
    optimizer = 'adam' ,
    loss = 'sparse_categorical_crossentropy',
    metrics = 'accuracy'
)

model.summary()

"""# Training the model"""

# prompt: code to increase learning rate  modify it for 20 epoch only

# Create a learning rate scheduler callback
lr_schedule = tf.keras.callbacks.LearningRateScheduler(
    lambda epoch: 1e-3 * 10**(epoch / 20)
)

# Train the model with the learning rate scheduler callback
history = model.fit(
    train_ds,
    validation_data=test_ds,
    epochs=10,
    callbacks=[lr_schedule]
)

#fit the model

from tensorflow.keras.models import Model
history = model.fit(train_ds , epochs = 20)

# code to save trained model

model.save('my_model.h5')

model.save('my_my_model.keras')

"""# Model evaluation result"""

# Accuracy and Loss Over Epochs

accuracy = history.history['accuracy']
loss = history.history['loss']
epochs = range(1, 21)

plt.plot(epochs, accuracy, label='Accuracy')
plt.plot(epochs, loss, label='Loss')
plt.legend()
plt.xlabel('Epochs')
plt.ylabel('Accuracy / Loss')
plt.title('Training History')
plt.show()

"""### Accuracy on Training dataset"""

result = model.evaluate(train_ds)

# Printing the result
print("Loss:", result[0])
print("Accuracy:", result[1])

"""### Accuracy on Test dataset

"""

result = model.evaluate(test_ds)

# Printing the result
print("Loss:", result[0])
print("Accuracy:", result[1])



"""# Test Model Predictions"""

# Preprocessing an image before passing it to a model for prediction

def img_to_pred(image):
  # Convert the image to a NumPy array
  image = image.numpy()
  # Add an extra dimension to the array
  image = tf.expand_dims(image,0)
  return image

"""Creating a subplot to visualize a batch of images from the test dataset and show their actual labels alongside the predicted labels

"""

plt.figure(figsize=(18, 18))
for images, labels in test_ds.take(1):
    for i in range(1, 19):
        plt.subplot(6, 3, i)
        plt.imshow(images[i-1].numpy().astype('uint32'))
        plt.axis('off')
        actual = classes[labels[i-1]]  # Corrected index
        predict = classes[np.argmax(model.predict(img_to_pred(images[i-1])))]  # Corrected index
        plt.title(f"actual : {actual}  \n predicted : {predict} ")

"""# Coverting output in json format"""

# Save accuracy and loss history to a dictionary
history_data = {
    'epochs': list(range(1, 21)),
    'accuracy': history.history['accuracy'],
    'loss': history.history['loss']
}
history_data

# Convert model evaluation results to a dictionary
train_evaluation = {
    'loss': result[0],
    'accuracy': result[1]
}

test_evaluation = {
    'loss': result[0],
    'accuracy': result[1]
}

# Save the model summary to a dictionary
model_summary = {
    'model_summary': model.summary()
}

# Convert the image predictions to a list of dictionaries
image_predictions = []
for images, labels in test_ds.take(1):
    for i in range(1, 19):
        actual = classes[labels[i-1]]
        predict = classes[np.argmax(model.predict(img_to_pred(images[i-1])))]
        image_predictions.append({
            'actual': actual,
            'predicted': predict
        })

# Combine all results into a final dictionary
output_data = {
    'history': history_data,
    'train_evaluation': train_evaluation,
    'test_evaluation': test_evaluation,
    'model_summary': model_summary,
    'image_predictions': image_predictions
}

# Convert the dictionary to JSON format
json_output = json.dumps(output_data, indent=4)

# Print or save the JSON output as needed
print(json_output)